指针的进阶

1. 字符指针
2. 数组指针
3. 指针数组
4. 数组传参和指针传参
5. 函数指针
6. 函数指针数组
7. 指向函数指针数组的指针
8. 回调函数
9. 指针和数组面试题的解析

正文开始

指针的主题，我们再初级阶段《指针》章节已经接触过了，我们知道了指针的概念：

1. 指针就是个变量，用来存放地址，地址唯一标识一块内存空间。
2. 指针的大小是固定的4或8个字节（32为平台或64位平台）。
3. 指针有类型，指针的类型决定了指针+整数的步长，指针解引用操作时候的权限。
4. 指针的运算。

这个章节我们继续探讨指针的高级主题。

## 字符指针

在指针的类型中我们知道有一种指针类型字符指针char*;

一般使用：

```c
#include <stdio.h>

int main()
{
	char ch = 'w';
	char* pc = &ch;
	*pc = 'w';

	return 0;
}
```

还有一种使用方式如下：

```c
#include <stdio.h>

int main()
{
	char* pstr = "hello bit.";//这里是把一个字符串放到pstr指针变量里面了吗？
	printf("%s\n", pstr);

	return 0;
}
```

代码char*pstr = "hello bit.";特别容易让人以为是把字符串hello bit.放到字符指针pstr里了，但是本质是把字符串hello.bit.首字符的地址放到了pstr中。

```c
#include <stdio.h>

int main()
{
	char* p = "abcdef";//"abcdef"是一个常量字符串
	printf("%c\n", *p);
	printf("%s\n", p);

	return 0;
}
```

上面代码的意思是把一个常量字符串的首字符h的地址存放到指针变量pstr中

```c
#include <stdio.h>

int main()
{
	const char* p = "abcdef";//"abcdef"是一个常量字符串
	//char* p = "abcdef"; *p = 'w'这种写法是错误的
	
	//printf("%c\n", *p);
	printf("%s\n", p);

	return 0;
}
```

那就可能有这样的面试题

```c
#include <stdio.h>

int main()
{
	char arr1[] = "abcdef";
	char arr2[] = "abcdef";
	const char* p1 = "abcdef";
	const char* p2 = "abcdef";

	if (p1 == p2)
	{
		printf("hehe\n");
	}
	else
	{
		printf("haha\n");
	}
	/*if (arr1 == arr2)
	{
		printf("hehe\n");
	}
	else
	{
		printf("haha\n");
	}*/

	return 0;
}
```

这里p1和p2指向的是同一个常量字符串。c/c++会把常量字符串存储到单独的一个内存区域，当几个指针。指向同一个字符串的时候，它们实际会指向同一块内存。但是用相同的常量字符串去初始化不同的数组的时候就会开辟出不同的内存块。所以p1和p2不同，arr1和arr2不同。

**指针数组**

在《指针》章节我们呢也学习了指针数组，指针数组是一个存放指针的数组。

这里我们再复习一下，下面指针数组是什么意思？

```c
int* arr1[10];//整型指针的数组
char* arr2[4];//一级字符串指针的数组
char** arr3[5];//二级指针字符串的数组
```

```c
#include<stdio.h>

int main()
{
	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;
	int* arr[4] = { &a,&b,&c,&d };
	int i = 0;
	for (i = 0;i < 4;i++)
	{
		printf("%d ", *(arr[i]));
	}
	return 0;
}
```

```c
#include<stdio.h>

int main()
{
	int arr1[] = { 1,2,3,4,5 };
	int arr2[] = { 2,3,4,5,6 };
	int arr3[] = { 3,4,5,6,7 };

	int* parr[] = { arr1,arr2,arr3 };
	int i = 0;
	for (i = 0;i < 3;i++)
	{
		int j = 0;
		for (j = 0;j < 5;j++)
		{
			printf("%d ", *(parr[i] + j));
		}
		printf("\n");
	}

	return 0;
}
```

## 数组指针

### **数组指针的定义**

数组指针是指针？还是数组？

答案是：指针。

我们已经熟悉：整型指针：int*pint;能够指向整型数据的指针。浮点型指针：float\*pf;能够指向浮点型数据的指针。

那数组指真应该是：能够指向数组的指针。

下面代码哪个是数组指针？

```c
int* p1[10];
int(*p2)[10];
//p1,p2分别是什么？
```

```c
int(*p)[10];
//解释：p先和*组合，说明p是一个指针变量，然后指向的是一个大小为10个整型
//的数组。所以p是一个指针，指向一个数组，叫数组指针。
//这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。
```

**&数组名VS数组名**

对于下面的数组

int arr[10];

arr和&arr分别是啥？

我们知道arr是数组名，数组名表示数组首元素的地址。

那&arr数组名到底是啥？

```c
#include<stdio.h>

int main()
{
	int arr[10] = { 0 };
	printf("%p\n", arr);
	printf("%p\n", &arr);

	return 0;
}
```

运行结果如下：

![1653875289521](C:\Users\gaoho\AppData\Roaming\Typora\typora-user-images\1653875289521.png)

难道两个是一样的吗？

我们再看一段代码：

```c
#include<stdio.h>

int main()
{
	int arr[10] = { 0 };
	printf("arr	= %p\n", arr);
	printf("&arr= %p\n", &arr);

	printf("arr+1= %p\n",arr + 1);
	printf("&arr+1= %p\n", &arr + 1);
	return 0;
}

```

运行结果：

![1653875476287](C:\Users\gaoho\AppData\Roaming\Typora\typora-user-images\1653875476287.png)

根据上面的代码我们发现，其实&arr和arr，虽然值是一样的，但是意义应该不一样的。

**实际上：**&arr表示的是**数组的地址，**而不是数组首元素的地址。（细细体会一下）

数组的地址+1，跳过整个数组的大小，所以&arr+1相对于&arr的差值是40.

**数组指针的使用**

那数组指针是怎么使用的呢？

既然数组指针指向的是数组，那数组指针中存放的应该是数组的地址。

看代码：

```c
#include<stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,0 };
	int(*p)[10] = &arr;//把数组arr的地址赋值给数组指针变量p
	//但是我们一般很少这样些代码
	return 0;
}

```

一个数组指针的使用：

```c
#include<stdio.h>

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int(*pa)[10] = &arr;
	int i = 0;

	for (i = 0;i < 10;i++)
	{
		printf("%d ",  *( * pa + i));
	}
	/*for (i = 0;i < 10;i++)
	{
		printf("%d ", (*pa)[i]);
	}*/
	return 0;
}
```

数组指针在二维数组中的应用

```c
#include<stdio.h>
//参数是数组的形式
print1(int arr[3][5], int x, int y)
{
	int i = 0;
	int j = 0;
	for (i = 0;i < x;i++)
	{
		for (j = 0;j < y;j++)
		{
			printf("%d ", arr[i][j]);
		}
		printf("\n");
	}
}
//参数是指针的形式
void print2(int(*p)[5], int x, int y)
{
	int i = 0;
	for (i = 0;i < x;i++)
	{
		int j = 0;
		for (j = 0;j < y;j++)
		{
			printf("%d ",p[i][j]);
			//printf("%d ",*(p[i]+j));
			//printf("%d ", *(*(p + i) + j));
			//printf("%d ", ( * (p + i))[j]);
		}0XY 
		printf("\n");
	}
}

int main()
{
	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
	print1(arr,3,5);
	print2(arr, 3, 5);
	return 0;
}
```

学习了指针数组和数组指针我们来一起回顾并看看下面代码的意思：

```c
int arr[5];//arr是一个5个元素的整型数组
int* parr[10];//parr1是一个数组，数组有10个元素，每个元素的类型是int*，parr1是指针数组。
int(*parr2)[10];//parr2是一个指针，该指针指向了一个数组，数组有10个元素，每个元素的类型是int -parr2是数组指针 
int(*parr3[10])[5];//parr3是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int.
```

## 数组参数、指针参数

在写代码的时候难免有时候要把【数组】或者【指针】传给函数，那函数的参数该如何设计呢？

### 一维数组传参

```c
#include<stdio.h>

void test(int arr[])//OK?
{}
void test(int arr[10])//OK?
{}
void test(int *arr)//OK?
{}
void test2(int *arr[20])//OK?
{}
void test2(int**arr[20])//OK?
{}
int main()
{
	int arr[10] = { 0 };
	int* arr2[20] = { 0 };
	test(arr);
	test(arr2);
}
```

以上都可以

二维数组传参

```c
#include<stdio.h>

void test(int arr[3][5])//OK?
{}
void test(int arr[][])//OK?//error
{}
void test(int arr[3][])//OK?//error
{}
void test(int *arr[][5])//OK?
{}
//总结：二维数组传参，函数形参设计只能省略第一个[]的数字
//因为对一个二维数组，可以不知道有多少行，但是必须知道一行多少元素
//这样才方便运算

void test(int *arr)//OK?//error
{}
void test(int* *arr)//OK?//error
{}
void test(int* arr[5])//OK?//error
{}
void test(int(* arr)[5])//OK?//OK
{}
void test(int**arr[])//OK?//error
{}
int main()
{
	int arr[3][5] = {0};
	test(arr);//二维数组传参
	return 0;
}
```

### 一级指针传参

```c
#include<stdio.h>

void print(int* p, int sz)
{
	int i = 0;
	for (i = 0;i < sz;i++)
	{
		printf("%d\n", *(p + i));
	}
}

int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
	int* p = arr;
	int sz = sizeof(arr) / sizeof(arr[0]);
	//一级指针p,传给函数
	print(p, sz);

	return 0;
}
```

思考：

当一个函数的参数部分为一级指针的时候，函数能接收什么参数？



比如：

```c
#include<stdio.h>

void test1(int* p)
{}
//test1函数能接收什么参数？
void test2(char* p)
{}
//test2函数能接收什么参数？

int main()
{
	int a = 10;
	int* p1 = &a;
	test1(&a);//OK
	test1(p1);//OK
	char ch = 'w';
	char* pc = &ch;
	test2(&ch);//OK
	test2(pc);//OK

	return 0;
}

```

### 二级指针传参

```c
#include<stdio.h>

void test(int** ptr)
{
	printf("num = %d\n", **ptr);
}
int main()
{
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	int* arr[10];
	test(arr);//指针数组也可以
	return 0;
}

```

思考：

当函数的参数为二级指针的时候，可以接收什么参数？

```c
#include<stdio.h>

void test(int** ptr)
{
	printf("num = %d\n", **ptr);
}
int main()
{
	int n = 10;
	int* p = &n;
	int** pp = &p;
	test(pp);
	test(&p);
	int* arr[10];
	test(arr);//指针数组也可以
	return 0;
}

```

## 函数指针

首先看一段代码：

```c
#include<stdio.h>
//数组指针 - 是指向数组的指针
//函数指针 - 是指向函数的指针 - 存放函数地址的一个指针
int Add(int x,int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 10;
	int b = 20;
	//&arr;
	// arr;
	//printf("%d\n", Add(a, b));
	//&函数名 和 函数名都是函数的地址
	/*printf("%p\n", &Add);
	printf("%p\n", Add);*/
	int(* pa)(int, int) = Add;
	printf("%d\n",(*pa)(2, 3));//5
	return 0;
}
```

![1653887078896](C:\Users\gaoho\AppData\Roaming\Typora\typora-user-images\1653887078896.png)

```
#include<stdio.h>
//数组指针 - 是指向数组的指针
//函数指针 - 是指向函数的指针
void Print(char*str)
{
	printf("%s\n", str);
}
int main()
{
	void(*p)(char*) = Print;
	(*p)("hello bit");

	return 0;
}

```

![1653887211747](C:\Users\gaoho\AppData\Roaming\Typora\typora-user-images\1653887211747.png)

**阅读两端有趣的代码：**

```c
//代码1
(*(void(*)())0)();//把0强制转换成：void(*)()函数指针类型 - 0就是函数的地址
				  //调用0地址的该函数
//代码2
//void(*signal(int, void(*)(int)))(int);
//void(        *signal(int, void(*)(int))       )(int);
//signal函数的参数有两个，第一个是int。第二个是函数指针，该函数指针指向的函数的参数是int,返回的类型是void.
//signal函数的返回类型也是一个函数指针：该函数指针指向的函数的参数是int，返回的类型是void
//简化
typedef void(*pfun_t)(int);
pfun_t signal(int, pfun_t);
typedef unsigned int uint;
```

注释:推荐《C陷阱和缺陷》

这本数提及这两个代码。

```c
#include<stdio.h>

int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}
int main()
{
	int a = 10;
	int b = 20;
	
	int(*pa)(int, int) = Add;
	printf("%d\n", pa(2, 3));
	printf("%d\n", Add(2, 3));
	printf("%d\n", (*pa)(2, 3));
	//printf("%d\n", (**pa)(2, 3));
	//printf("%d\n", (***pa)(2, 3));
	return 0;
}
```

## 函数指针数组

数组是一个存放相同类型数据的存储空间，那我们已经学习了指针数组，比如：

```c
int* arr[5];
//数组的每个元素都是int*
```

那要把函数的地址存到一个数组中，那这个数组就叫函数指针数组，那函数指针的数组如何定义呢？

```c
int(*parr1[10])();
int* parr2[10]();
int(*)()parr3[10];
```

答案是：**parr1** parr1先和[]结合，说明parr1是数组，数组的内容是什么呢？是int(*)()类型的函数指针。

函数指针数组的用途：**转移表**

例子：（计算器）

```c
#include<stdio.h>

int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
int main()
{
	//指针数组
	//int* arr[5];
	//需要一个数组，这个数组可以存放4个函数的地址 - 函数指针的数组
	int (*pa)(int, int) = Add;//Sub/Mul/Div
	int (*parr[4])(int, int) = { Add,Sub,Mul,Div };//函数指针的数组
	int i = 0;
	for (i = 0;i < 4;i++)
	{
		printf("%d\n", parr[i](2, 3));//5 -1 6 0
	}
	return 0;
}
```

```c
#include<stdio.h>

void menu()
{
	printf("***********************\n");
	printf("**  1.add       2.sub**\n");
	printf("**  3.mul       4.div**\n");
	printf("**        0.exit     **\n");
	printf("***********************\n");
}
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}

//计算器
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	do
	{
		menu();
		printf("请选择：>");
		scanf("%d", &input);
		//printf("请输入两个操作数：");
		//scanf("%d%d", &x, &y);
		switch(input)
		{
			case 1:
				printf("请输入两个操作数：");
				scanf("%d%d", &x, &y);
				printf("%d\n", Add(x, y));
				break;
			case 2:
				printf("请输入两个操作数：");
				scanf("%d%d", &x, &y);
				printf("%d\n", Sub(x, y));
				break;
			case 3:
				printf("请输入两个操作数：");
				scanf("%d%d", &x, &y);
				printf("%d\n", Mul(x, y));
				break;
			case 4:
				printf("请输入两个操作数：");
				scanf("%d%d", &x, &y);
				printf("%d\n", Div(x, y));
				break;
			case 0:
				printf("退出\n");
			default:
				printf("选择错误\n");
		}
	} while (input);

	return 0;
}
```

```c
#include<stdio.h>

void menu()
{
	printf("***********************\n");
	printf("**  1.add       2.sub**\n");
	printf("**  3.mul       4.div**\n");
	printf("**  5.Xor       0.exit*\n");
	printf("***********************\n");
}
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}

int Xor(int x, int y)
{
	return x ^ y;
}

//计算器
int main()
{
	int input = 0;
	int x = 0;
	int y = 0;
	//pfArr是一个函数指针数组 - 转移表
	int (*pfArr[])(int, int) = {0,Add,Sub,Mul,Div,Xor};
	do
	{
		menu();
		printf("请选择：>");
		scanf("%d", &input);
		if(input >= 1 && input <= 5)
		{
			printf("请输入两个操作数：>");
			scanf("%d%d", &x, &y);
			int ret = pfArr[input](x, y);
			printf("%d\n", ret);
		}
		else if (input == 0)
		{
			printf("退出\n");
		}
		else
		{
			printf("选择错误\n");
		}
	} while (input);

	return 0;
}
```

## 指向函数指针数组的指针

**指向函数指针数组的指针是一个**指针 **指针指向一个**数组，**数组的元素**都是函数指针；

如何定义？

```c
#include<stdio.h>

int Add(int x, int y)
{
	return x + y;
}
int main()
{
	int arr[10] = { 0 };
	int (*p)[10] = & arr;//取出数组的地址

	int(*pf)(int, int);//函数指针
	int(*pfArr[4])(int, int);//pfArr是一个数组 - 函数指针的数组
	//ppfArr是一个指向【函数指针数组】的指针
	int(*(*ppfArr[4]))(int, int) = &pfArr;
	//
	//ppfArr 是一个数组指针，指针指的数组有4个元素。
	//指向的数组的每个元素的类型是一个函数指针int(*)(int,int)
	//
	return 0;
}
```





## 回调函数

回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是有该函数的实现方式直接调用，而是在特定的时间或者条件发生时由另外的一方调用的，用于对该事件或条件进行响应。

首先演示一下qsort函数的使用：

```c
#include<stdio.h>

print(char* str)
{
	printf("hehe:%s", str);
}

void test(void(*p)(char*))
{
	printf("test\n");
	p("bit");
}
int main()
{
	test(print);c
	return 0;
}
```

计算机

```c
#include<stdio.h>

void menu()
{
	printf("***********************\n");
	printf("**  1.add       2.sub**\n");
	printf("**  3.mul       4.div**\n");
	printf("**        0.exit     **\n");
	printf("***********************\n");
}
int Add(int x, int y)
{
	return x + y;
}
int Sub(int x, int y)
{
	return x - y;
}
int Mul(int x, int y)
{
	return x * y;
}
int Div(int x, int y)
{
	return x / y;
}
//回调函数
Calc(int (*pf)(int, int))
{
	int x = 0;
	int y = 0;
	printf("请输入两个操作数:>");
	scanf("%d%d", &x, &y);
	printf("%d\n", pf(x, y));
}

//计算器
int main()
{
	int input = 0;
	do
	{
		menu();
		printf("请选择：>");
		scanf("%d", &input);
		//printf("请输入两个操作数：");
		//scanf("%d%d", &x, &y);
		switch (input)
		{
		case 1:
			Calc(Add);
			break;
		case 2:
			Calc(Sub);
			break;
		case 3:
			Calc(Mul);
			break;
		case 4:
			Calc(Div);
			break;
		case 0:
			printf("退出\n");
			break;
		default:
			printf("选择错误\n");
		}
	} while (input);

	return 0;
}
```

```c
#include<stdio.h>
int main()
{
	int a = 10;
	/*int* pa = &a;
	char* pc = &a;
	char ch = 'w';*/
	void* p = &a;
	//*p = 0;
	// p++
	
	//p = &ch;
	//void*类型的指针 可以接收任意类型的地址
	//void*类型的指针 不能进行解引用操作
	//void*类型的指针 不能进行+-整型的操作
	return 0;
}
```

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//void bubble_sort(int arr[], int sz)
//{
//	int i;
//	for (i = 0;i < sz;i++)
//	{
//		int j = 0;
//		for (j = 0;j < sz - i - 1;j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//
//}

//定义结构体学生
struct Stu
{
	char name[20];
	int age;
};

//void qsort(void* base, size_t num, size_t width, int(*cmp)(const void* e1, const void* e2))
//{
//
//}

//整型排序
int cmp_int(const void* e1, const void* e2)
{
	//比较两个整型值的
	return *(int*)e1 - *(int*)e2;
}

//打印整型排序
void test1()
{
	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	//struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	//float f[] = { 9.0,8.0,7.0,6.0,5.0,4.0 };
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	//bubble_sort(arr,sz);

	int i = 0;
	for (i = 0;i < sz;i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}

//浮点数排序
int cmp_float(const void* e1, const void* e2)
{
	return *(float*)e1 - *(float*)e2;
}

//打印浮点数排序
void test2()
{
	float f[] = { 9.0,8.0,7.0,6.0,5.0,4.0 };
	int sz = sizeof(f) / sizeof(f[0]);
	qsort(f, sz, sizeof(f[0]), cmp_float);
	int j = 0;
	for (j = 0;j < sz;j++)
	{
		printf("%f ", f[j]);
	}
	printf("\n");
	
}

//根据学生的年龄来排序
int cmp_stu_by_age(const void* e1, const void* e2)
{
	return ((struct Stu*)e1)->age - ((struct Stu*)e2)->age;
}

//根据姓名排序
int cmp_stu_by_name(const void* e1, const void* e2)
{
	//比较名字就是比较字符串
	//字符串比较不能直接用><=来比较，应该用strcmp函数
	return strcmp(((struct Stu*)e1)->name,((struct Stu*)e2)->name);
}

//打印根据年龄排序
void test3()
{
	struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_age);
	int m;
	for (m = 0;m < sz; m++)
	{
		printf("%-15s%6d\n", s[m].name,s[m].age);
	}
}

//打印根据姓名排序
void test4()
{
	struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
	int m;
	for (m = 0;m < sz; m++)
	{
		printf("%-15s%6d\n", s[m].name, s[m].age);
	}
}

int main()
{
	test1();
	test2();
	test3();
	test4();

	return 0;
}
```

**全类型数据冒泡排序**

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
//void bubble_sort(int arr[], int sz)
//{
//	int i;
//	for (i = 0;i < sz;i++)
//	{
//		int j = 0;
//		for (j = 0;j < sz - i - 1;j++)
//		{
//			if (arr[j] > arr[j + 1])
//			{
//				int tmp = arr[j];
//				arr[j] = arr[j + 1];
//				arr[j + 1] = tmp;
//			}
//		}
//	}
//
//}

//定义结构体学生
struct Stu
{
	char name[20];
	int age;
};

//void qsort(void* base, size_t num, size_t width, int(*cmp)(const void* e1, const void* e2))
//第一个参数：待排序数组的首元素地址
// 第二个参数：待排序数组的元素个数
// 第三个参数：待排序数组的每个元素的大小 - 单位是字节
// 第四个参数：是函数指针，比较两个元素的所用函数的地址-这个
// 函数使用者自己实现
// 
//{
//
//}

//整型排序
int cmp_int(const void* e1, const void* e2)
{
	//比较两个整型值的
	return *(int*)e1 - *(int*)e2;
}

//打印整型排序
void test1()
{
	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	//struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	//float f[] = { 9.0,8.0,7.0,6.0,5.0,4.0 };
	qsort(arr, sz, sizeof(arr[0]), cmp_int);
	//bubble_sort(arr,sz);

	int i = 0;
	for (i = 0;i < sz;i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}

//浮点数排序
int cmp_float(const void* e1, const void* e2)
{
	return *(float*)e1 - *(float*)e2;
}

//打印浮点数排序
void test2()
{
	float f[] = { 9.0,8.0,7.0,6.0,5.0,4.0 };
	int sz = sizeof(f) / sizeof(f[0]);
	qsort(f, sz, sizeof(f[0]), cmp_float);
	int j = 0;
	for (j = 0;j < sz;j++)
	{
		printf("%f ", f[j]);
	}
	printf("\n");
	
}

//根据学生的年龄来排序
int cmp_stu_by_age(const void* e1, const void* e2)
{
	return ((struct Stu*)e1)->age - ((struct Stu*)e2)->age;
}

//根据姓名排序
int cmp_stu_by_name(const void* e1, const void* e2)
{
	//比较名字就是比较字符串
	//字符串比较不能直接用><=来比较，应该用strcmp函数
	return strcmp(((struct Stu*)e1)->name,((struct Stu*)e2)->name);
}

//打印根据年龄排序
void test3()
{
	struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_age);
	int m;
	for (m = 0;m < sz; m++)
	{
		printf("%-15s%6d\n", s[m].name,s[m].age);
	}
}

//打印根据姓名排序
void test4()
{
	struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	int sz = sizeof(s) / sizeof(s[0]);
	qsort(s, sz, sizeof(s[0]), cmp_stu_by_name);
	int m;
	for (m = 0;m < sz; m++)
	{
		printf("%-15s%6d\n", s[m].name, s[m].age);
	}
}

//void qsort(void* base, size_t num, size_t width, int(*cmp)(const void* e1, const void* e2))
//第一个参数：待排序数组的首元素地址
// 第二个参数：待排序数组的元素个数
// 第三个参数：待排序数组的每个元素的大小 - 单位是字节
// 第四个参数：是函数指针，比较两个元素的所用函数的地址-这个
// 函数使用者自己实现
// 
//{
//
//}

//实现bubble_sort函数的程序员，他是否知道未来排序的数据类型-不知道
//那程序员也不知道，带比较的两个元素的类型


void Swap(char* buf1, char* buf2,int width)
{
	int i = 0;
	for (i = 0;i < width;i++)
	{
		char tmp = *buf1;
		*buf1 = *buf2;
		*buf2 = tmp;
		buf1++;
		buf2++;
	}
}

//自己实现qsort排序功能
void bubble_sort(void* base, int sz, int width,int(*cmp)(void*e1,void*e2))
{
	int i = 0;
	//趟数
	for (i = 0;i < sz - 1;i++)
	{
		//每一趟比较的对数
		int j = 0;
		for (j = 0;j < sz - 1 - i;j++)
		{
			//两个元素的比较
			if (cmp((char*)base+j*width, (char*)base + (j + 1) * width) > 0)
			{
				//交换
				Swap((char*)base + j * width, (char*)base + (j + 1) * width,width);
			}
		}
	}
}
void test5()
{
	int arr[10] = { 9,8,7,6,5,4,3,2,1,0 };
	int sz = sizeof(arr) / sizeof(arr[0]);
	//使用bubble_sort的程序员一定知道自己排序的是什么数据
	//就应该知道如何比较待排序数组中的元素
	bubble_sort(arr,sz,sizeof(arr[0]),cmp_int);
	int i = 0;
	for (i = 0;i < sz;i++)
	{
		printf("%d ", arr[i]);
	}
	printf("\n");
}

void test6()
{
	struct Stu s[3] = { {"zhangsan",20},{"lisi",30},{"wangwu",10} };
	int sz = sizeof(s) / sizeof(s[0]);
	bubble_sort(s, sz, sizeof(s[0]), cmp_stu_by_age);
	int m;
	for (m = 0;m < sz; m++)
	{
		printf("%-15s%6d\n", s[m].name, s[m].age);
	}
	
}



int main()
{
	test1();
	test2();
	test3();
	test4();
	test5();
	test6();

	return 0;
}
```

## 指针和数组笔试题解析

//一维数组

```c

int main()
{
	//数组名是首元素的地址
	// 1.sizeof(数组名) - 数组名表示整个数组
	// 2.&数组名-数组名表示整个数组
	//一维数组
	int a[] = { 1,2,3,4 };//4*4 = 16
	printf("%d\n", sizeof(a)); //sizeof(数组名) - 计算的是数组总大小 - 单位是字节 - 16
	printf("%d\n", sizeof(a + 0));//4/8 - 数组名这里表示首元素的值，a+0还是首元素地址，地址的大小就是4/8字节
	printf("%d\n", sizeof(*a));//4 - 数组名表示首元素地址，*a就是首元素，sizeof(*a)就是4
	printf("%d\n", sizeof(a + 1));//4/8 - 数组名这里表示首元素的值，a+1第2个元素的地址，地址的大小就是4/8字节
	printf("%d\n", sizeof(a[1]));//4 - 第二元素的大小
	printf("%d\n", sizeof(&a));//4/8 &a取出的是数组的地址，但是数组的地址也是地址，地址的大小就是4/8
	printf("%d\n", sizeof(*&a));//16 - &a是数组地址，数组的地址解引用访问的数组，sizeof计算的就是数组的大小单位是字节
	printf("%d\n", sizeof(&a + 1));//4/8 - &a是数组地址 &a+1虽然地址跳过这个数组，但还是4/8个字节
	printf("%d\n", sizeof(&a[0]));//4/8 - &a[0]第一个元素的地址
	printf("%d\n", sizeof(&a[0] + 1));//4/8 - &a[1]第二的元素的地址
}

```

//字符数组

```c
#include<stdio.h>
#include<string.h>
int main()
{
	//字符数组
	char arr[] = { 'a','b','c','d','e','f' };
	printf("%d\n", sizeof(arr));//1*6 = 6字节 - sizeof计算的是数组大小 
	printf("%d\n", sizeof(arr + 0));//4/8 - arr是首元素的地址，arr+0还是首元素的地址 地址的大小是4/8字节
	printf("%d\n", sizeof(*arr));//1 - arr是首元素的地址，*arr就是首元素，首元素是字符大小一个字节
	printf("%d\n", sizeof(arr[1]));//1
	printf("%d\n", sizeof(&arr));//4/8 虽然是数组的地址，但是还是地址，地址的大小是4/8个字节
	printf("%d\n", sizeof(&arr + 1));//4/8 数组的地址+1跳过整个数组，还是地址大小位4个字节
	printf("%d\n", sizeof(&arr[0] + 1));//4/8 第二个元素的地址大小4/8个字节

	printf("%d\n", strlen(arr));//随机值
	printf("%d\n", strlen(arr + 0));//随机值
	//printf("%d\n", strlen(*arr));//error
	//printf("%d\n", strlen(arr[1]));//error
	printf("%d\n", strlen(&arr));//随机值
	printf("%d\n", strlen(&arr+1));//随机值
	printf("%d\n", strlen(&arr[0]+1));//随机值
}

```

